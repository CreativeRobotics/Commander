# Commander is a system for handling commands sent over serial ports or other Stream objects.

## Its designed to make it easy to create complex and powerful text based interfaces for controlling your sketch.

It allows you to define a list of text commands, a function to handle each command, and some help text that can be displayed when the 'help' command is sent. All the work of reading the incoming stream data, identifying the appropriate function and calling the handler is done by the commander object. It will run on most Arduino boards but is more suited to devices with large memory.

Commander is attached to Stream objects so it can be used with Serial ports, files on a SD cards, or Bluetooth Serial and other Stream based objects on wireless capable Arduinos such as the ESP32.

Commander can have up to three Stream objects connected at once, an input stream, output stream and auxiluary stream. As well as reading commands and passing them to the handler functions Commander can route or copy data to another port, echo data back to you and redirect or copy responses to a different port. When using SDFat Commanders input Stream can be attached to one file to read commands, and the output Stream attached to a second file for logging any responses generated by the command handler, with the aux stream copying all those responses to a serial port.

Commander is designed so that the list of commands and associated handlers and help text is seperate from the Commander object, this allows command lists to be shared between several instances of a Commander object, for example where the same command set needs to be available via USB and Bluetooth Serial. It also allows different command lists to be dynamically loaded so multiple command lists, and multiple Commander objects can be combined to produce hierarchical command structures.

Nested commands are allowed and Commander incorporates a set of functions for extracting any payload that comes after a command and for parsing variables in the payload. It can also augment responses sent to its output and auxiluary Streams to add prefix and postfix text, for example enclosing each line with opening and closing html tags, or prefixing specified lines with a command.

Built in commands like Help will generate a help page listing all the commands and any help text for them. Additional built in commands can be used to toggle error reporting and port echoing and all built in commands can be overidden by the user with their own handler.

Commander can use an optional command prompt with user defined text to emulate the feel of a command line, this prompt can be changed dynamically to indicate the current context, for example it can show the working directory of a file system, or the title of a sub command list. Commander also has a user defined 'reaload' character that will reload the last command. By default this is / so, for example, if you sent a command called 'print sensors' and then want to send the same command again, you just need to type / to repeat it. A user defined 'comment' character (# by default) can be put in front of a line to tell Commander to ignore it.

### The following list of examples demonstrate various ways to use Commander:

__BasicCommands:__ Demonstrated setting and getting integer and float values with a command list.

__QuickSet:__ Demonstrates an in built method for packing some commands in a single command handler for faster coding whilst retaining the help system for listing commands.

__ESP32-SerialBTCommands:__ Uses a BluetoothSerial object so commands can be sent vial bluetooth.

__FileRead:__ Open an SD card file that contains a set of commands and read the contents into Commander. Responses to commands are fed back to a Serial port.

__FileReadLog:__ Open an SD card file that contains a set of commands and read the contents into Commander. Responses to commands are written to another file and copied to a Serial port.

__FileNavigation:__ Used SDFat and a set of commands for listing files, navigating and creating directories, renaming and deleting files and directories and printing out files.

__FormattedReplies:__ Shows how to use the pre and posfix formating, and nested commands so formatting for another command can be invoked.

__SimpleMultiLayer:__ Shows how three command lists can be used with one Commander object to create a multi level command structure. This example has sub commands for setting variable, and more for reading back variables. These commands can be invoked from the top level (e.g 'get int') or the sub level can be invoked ('get') and then commands from that level invoked directly ('int') before an 'exit' command returns you to the top level. The help command can be used for every level.

__FullMultiLayer:__ This example behaves in an almost identical way to SimpleMultiLayer but uses three Commander objects. Navigating between different levels is handled by passing control from one Commander object to another rather than loading different command lists into the same object.

__NumberCommand:__ (To Be Done!) Demonstrates a special class of command for handling numbers. It is designed to allow data files to be uploaded and unpacked into an array.

__TelnetCommand:__ (To Be Done) Interface a Telnet session to Commander so that commands can be accessed remotely via WiFi.

__htmlCommand:__ (To Be Done) Feed HTML page requests to Commander and generate HTML formatted responses in reply.


### How it works (roughly speaking)

The command list is an array of structures and each element contains the command string, a function pointer, and a help text string. When you load a command list into a Commander object is scans the list and records the lengths of all the commands.

When Commander reads a Stream or is fed a String it tries to match the start of the string to a command (unless it was rejected as a comment or the reload character was detected). If a command match is found it invokes the command handler function (supplied by the user) and waits for it to finish.

If it can't find a match it looks for one in the built in commands and will execute their handlers if a match is found. When Commander is finished it will check to see if the command prompt is enabled and of so, it will print out the prompt on a new line.

Because Commander checks the user commands first you can overide any of the built in commands with your own.

There are a full set of Stream print and write functions that can be used, and they ensure that responses will be routed to the Commander objects specified output port, and to the aux port if enabled, and they ensure that any pre or postfix formatting is applied.

The command match system relies on each comment ending with either a newline or a space. If the command doesn't have any arguments it will normally end in a newline but if it has any arguments then they must be seperated by a space or the user defined eocCharacter (space by default) - By setting eocCharacter to '=' you can use a command to set a parameter such as 'myvariable=3' rather than 'myvariable 3' (although both will work).

Disclaimer: I'm not the best software engineer in the world so there may be some bits of sillyness in my code. I welcome contributions that will improve Commander so long as they maintain a good balance between features and efficiency.

Other to be done: Better documantation of the API and a Git Wiki.

Disclaimer: I'm not the best software engineer in the world so there may be some bits of sillyness in my code. I welcome contributions that will improve Commander so long as they maintain a good balance between features and efficiency.

Written by Bill Bigge.
MIT license, all text above must be included in any redistribution
